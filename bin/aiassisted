#!/bin/sh
#
# aiassisted - AI-Assisted Engineering Guidelines Installer
# 
# A multi-runtime CLI orchestrator that delegates to shell, Python (UV), or Bun backends.
#
# Usage:
#   aiassisted install [--path=DIR] [--verbose] [--quiet] [--runtime=<shell|python|bun>]
#   aiassisted update [--force] [--path=DIR] [--verbose] [--quiet] [--runtime=<shell|python|bun>]
#   aiassisted check [--path=DIR] [--runtime=<shell|python|bun>]
#   aiassisted version [--runtime=<shell|python|bun>]
#   aiassisted self-update
#   aiassisted runtime list
#   aiassisted runtime set <shell|python|bun>
#   aiassisted help
#

set -e

# Version (used by version command in some contexts)
# shellcheck disable=SC2034
VERSION="2.0.0"

# Get script directory
# If this is a symlink, resolve to the actual source location
if [ -L "$0" ]; then
    # Resolve symlink to get source directory
    _real_path="$(readlink "$0")"
    if [ "${_real_path#/}" = "$_real_path" ]; then
        # Relative path - make absolute
        _real_path="$(dirname "$0")/$_real_path"
    fi
    SCRIPT_DIR="$(cd "$(dirname "$_real_path")/.." && pwd)"
else
    # Not a symlink - running from source directly
    SCRIPT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
fi

# Export SCRIPT_DIR so runtime backends can access it
export SCRIPT_DIR

# Config file location (centralized in ~/.aiassisted)
CONFIG_DIR="$HOME/.aiassisted"
CONFIG_FILE="$CONFIG_DIR/config"

# Color support detection
if [ -t 1 ] && command -v tput >/dev/null 2>&1; then
    COLORS=$(tput colors 2>/dev/null || echo 0)
    if [ "$COLORS" -ge 8 ]; then
        COLOR_RESET="$(tput sgr0)"
        COLOR_RED="$(tput setaf 1)"
        COLOR_GREEN="$(tput setaf 2)"
        COLOR_YELLOW="$(tput setaf 3)"
        COLOR_BLUE="$(tput setaf 4)"
        COLOR_BOLD="$(tput bold)"
    fi
fi

# Fallback to no colors if not set
COLOR_RESET="${COLOR_RESET:-}"
COLOR_RED="${COLOR_RED:-}"
COLOR_GREEN="${COLOR_GREEN:-}"
COLOR_YELLOW="${COLOR_YELLOW:-}"
COLOR_BLUE="${COLOR_BLUE:-}"
COLOR_BOLD="${COLOR_BOLD:-}"

###########################################
# Logging Functions
###########################################

log_error() {
    printf "%s[ERROR]%s %s\n" "$COLOR_RED" "$COLOR_RESET" "$1" >&2
}

log_success() {
    printf "%s[SUCCESS]%s %s\n" "$COLOR_GREEN" "$COLOR_RESET" "$1"
}

log_info() {
    printf "%s[INFO]%s %s\n" "$COLOR_BLUE" "$COLOR_RESET" "$1"
}

log_warn() {
    printf "%s[WARN]%s %s\n" "$COLOR_YELLOW" "$COLOR_RESET" "$1"
}

###########################################
# Runtime Detection
###########################################

# Detect available runtimes
# Returns: space-separated list of available runtimes
detect_available_runtimes() {
    _available=""
    
    # Shell is always available (if runtime exists)
    if [ -f "$SCRIPT_DIR/src/shell/core.sh" ]; then
        _available="shell"
    fi
    
    # Check for UV (Python) and runtime implementation
    if command -v uv >/dev/null 2>&1 && [ -f "$SCRIPT_DIR/src/python/pyproject.toml" ]; then
        _available="$_available python"
    fi
    
    # Check for Bun and runtime implementation
    if command -v bun >/dev/null 2>&1 && [ -f "$SCRIPT_DIR/src/bun/package.json" ]; then
        _available="$_available bun"
    fi
    
    echo "$_available"
}

# Get preferred runtime from config or auto-detect
get_preferred_runtime() {
    _explicit_runtime=""
    
    # Check for --runtime flag in args
    for _arg in "$@"; do
        case "$_arg" in
            --runtime=*)
                _explicit_runtime="${_arg#*=}"
                ;;
        esac
    done
    
    # If explicit runtime specified, use it
    if [ -n "$_explicit_runtime" ]; then
        echo "$_explicit_runtime"
        return 0
    fi
    
    # Check config file
    if [ -f "$CONFIG_FILE" ]; then
        _config_runtime=$(grep "^RUNTIME=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
        if [ -n "$_config_runtime" ]; then
            echo "$_config_runtime"
            return 0
        fi
    fi
    
    # Auto-detect: prefer python > bun > shell (only if backend exists)
    _available=$(detect_available_runtimes)
    
    case "$_available" in
        *python*)
            echo "python"
            ;;
        *bun*)
            echo "bun"
            ;;
        *shell*)
            echo "shell"
            ;;
        *)
            # Fallback: shell even if backend missing (will error later)
            echo "shell"
            ;;
    esac
}

# Verify runtime is available
# Returns: 0 if available, 1 if not
verify_runtime() {
    _runtime="$1"
    
    case "$_runtime" in
        shell)
            return 0
            ;;
        python)
            if command -v uv >/dev/null 2>&1; then
                return 0
            else
                log_error "Python runtime requires 'uv' to be installed"
                log_info "Install UV: https://docs.astral.sh/uv/getting-started/installation/"
                return 1
            fi
            ;;
        bun)
            if command -v bun >/dev/null 2>&1; then
                return 0
            else
                log_error "Bun runtime requires 'bun' to be installed"
                log_info "Install Bun: https://bun.sh/docs/installation"
                return 1
            fi
            ;;
        *)
            log_error "Unknown runtime: $_runtime"
            return 1
            ;;
    esac
}

###########################################
# Runtime Commands
###########################################

cmd_runtime_help() {
    cat <<'EOF'
aiassisted runtime - Manage runtime backends

Usage:
  aiassisted runtime <subcommand> [options]

Subcommands:
  list              List available runtimes and show which is active
  set <runtime>     Set preferred runtime (shell, python, bun)
  info              Show current runtime information
  help              Show this help message

Runtimes:
  shell             POSIX-compliant shell (default, zero dependencies)
  python            Python + UV runtime (fast, parallel downloads)
  bun               Bun + TypeScript runtime (fastest)

Examples:
  # List all available runtimes
  aiassisted runtime list

  # Set preferred runtime to Python
  aiassisted runtime set python

  # Show current runtime info
  aiassisted runtime info

  # Override runtime for single command
  aiassisted install --runtime=shell
  aiassisted update --runtime=python

Notes:
  - Shell runtime is always available (zero dependencies)
  - Python runtime requires UV to be installed
  - Bun runtime requires Bun to be installed
  - Use --runtime=<name> flag to override for single command
  - Runtime preference is saved to ~/.config/aiassisted/config

For more information, visit:
  https://github.com/rstlix0x0/aiassisted
EOF
}

cmd_runtime_list() {
    printf "\n%s%sAvailable Runtimes:%s\n\n" "$COLOR_BOLD" "$COLOR_GREEN" "$COLOR_RESET"
    
    _available=$(detect_available_runtimes)
    _preferred=$(get_preferred_runtime "$@")
    
    # Shell
    if echo "$_available" | grep -q "shell"; then
        if [ "$_preferred" = "shell" ]; then
            printf "  %s✓ shell%s (default, active)\n" "$COLOR_GREEN" "$COLOR_RESET"
        else
            printf "  %s✓ shell%s (default)\n" "$COLOR_GREEN" "$COLOR_RESET"
        fi
    fi
    
    # Python
    if echo "$_available" | grep -q "python"; then
        _uv_version=$(uv --version 2>/dev/null | cut -d' ' -f2)
        if [ "$_preferred" = "python" ]; then
            printf "  %s✓ python%s (detected: uv %s, active)\n" "$COLOR_GREEN" "$COLOR_RESET" "$_uv_version"
        else
            printf "  %s✓ python%s (detected: uv %s)\n" "$COLOR_GREEN" "$COLOR_RESET" "$_uv_version"
        fi
    else
        printf "  %s✗ python%s (requires uv)\n" "$COLOR_RED" "$COLOR_RESET"
    fi
    
    # Bun
    if echo "$_available" | grep -q "bun"; then
        _bun_version=$(bun --version 2>/dev/null)
        if [ "$_preferred" = "bun" ]; then
            printf "  %s✓ bun%s (detected: %s, active)\n" "$COLOR_GREEN" "$COLOR_RESET" "$_bun_version"
        else
            printf "  %s✓ bun%s (detected: %s)\n" "$COLOR_GREEN" "$COLOR_RESET" "$_bun_version"
        fi
    else
        printf "  %s✗ bun%s (not installed)\n" "$COLOR_RED" "$COLOR_RESET"
    fi
    
    printf "\n"
}

cmd_runtime_set() {
    _new_runtime="$1"
    
    if [ -z "$_new_runtime" ]; then
        log_error "Runtime name required"
        printf "Usage: aiassisted runtime set <shell|python|bun>\n"
        exit 1
    fi
    
    # Verify runtime exists
    case "$_new_runtime" in
        shell|python|bun)
            ;;
        *)
            log_error "Unknown runtime: $_new_runtime"
            printf "Valid runtimes: shell, python, bun\n"
            exit 1
            ;;
    esac
    
    # Verify runtime is available
    if ! verify_runtime "$_new_runtime"; then
        exit 1
    fi
    
    # Create config directory
    if [ ! -d "$CONFIG_DIR" ]; then
        if ! mkdir -p "$CONFIG_DIR"; then
            log_error "Failed to create config directory"
            exit 1
        fi
    fi
    
    # Write config
    echo "RUNTIME=$_new_runtime" > "$CONFIG_FILE"
    
    log_success "Set preferred runtime to: $_new_runtime"
    log_info "Config saved to: $CONFIG_FILE"
}

cmd_runtime_info() {
    _runtime=$(get_preferred_runtime "$@")
    
    printf "\n%s%sCurrent Runtime:%s\n\n" "$COLOR_BOLD" "$COLOR_GREEN" "$COLOR_RESET"
    printf "  Runtime: %s%s%s\n" "$COLOR_BOLD" "$_runtime" "$COLOR_RESET"
    
    case "$_runtime" in
        python)
            _uv_version=$(uv --version 2>/dev/null | cut -d' ' -f2)
            printf "  Tool:    uv %s\n" "$_uv_version"
            printf "  Command: uv run python -m aiassisted\n"
            ;;
        bun)
            _bun_version=$(bun --version 2>/dev/null)
            printf "  Tool:    bun %s\n" "$_bun_version"
            printf "  Command: bun run src/index.ts\n"
            ;;
        shell)
            printf "  Tool:    POSIX sh\n"
            printf "  Command: sh src/shell/core.sh\n"
            ;;
    esac
    
    if [ -f "$CONFIG_FILE" ]; then
        printf "  Config:  %s\n" "$CONFIG_FILE"
    fi
    
    printf "\n"
}

###########################################
# Runtime Delegation
###########################################

delegate_to_runtime() {
    _runtime="$1"
    shift
    
    # Filter out --runtime flag from args before delegating
    _filtered_args=""
    for _arg in "$@"; do
        case "$_arg" in
            --runtime=*)
                # Skip runtime flag
                ;;
            *)
                _filtered_args="$_filtered_args $_arg"
                ;;
        esac
    done
    
    case "$_runtime" in
        shell)
            # shellcheck disable=SC2086
            exec sh "$SCRIPT_DIR/src/shell/core.sh" $_filtered_args
            ;;
        python)
            # Use UV to run Python module
            # shellcheck disable=SC2086
            cd "$SCRIPT_DIR/src/python" && exec uv run python -m aiassisted $_filtered_args
            ;;
        bun)
            # Use Bun to run TypeScript
            # shellcheck disable=SC2086
            cd "$SCRIPT_DIR/src/bun" && exec bun run src/index.ts $_filtered_args
            ;;
        *)
            log_error "Unknown runtime: $_runtime"
            exit 1
            ;;
    esac
}

###########################################
# Main Entry Point
###########################################

main() {
    # Get command
    _command="${1:-help}"
    
    # Handle runtime-specific commands
    case "$_command" in
        runtime)
            _subcommand="${2:-info}"
            shift 2 || shift 1 || true
            
            case "$_subcommand" in
                list)
                    cmd_runtime_list "$@"
                    exit 0
                    ;;
                set)
                    cmd_runtime_set "$@"
                    exit 0
                    ;;
                info)
                    cmd_runtime_info "$@"
                    exit 0
                    ;;
                help|-h|--help)
                    cmd_runtime_help
                    exit 0
                    ;;
                *)
                    log_error "Unknown runtime subcommand: $_subcommand"
                    printf "Valid subcommands: list, set, info, help\n"
                    printf "Run 'aiassisted runtime help' for more information\n"
                    exit 1
                    ;;
            esac
            ;;
        self-update)
            # Self-update is handled by shell only (updates this orchestrator)
            exec sh "$SCRIPT_DIR/src/shell/core.sh" "$@"
            ;;
    esac
    
    # Get preferred runtime
    _runtime=$(get_preferred_runtime "$@")
    
    # Verify runtime is available
    if ! verify_runtime "$_runtime"; then
        log_warn "Falling back to shell runtime"
        _runtime="shell"
    fi
    
    # Delegate to runtime
    delegate_to_runtime "$_runtime" "$@"
}

# Run main function
main "$@"
